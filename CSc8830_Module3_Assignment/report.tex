\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{float}
\usepackage{booktabs}

\title{\textbf{CSc 8830 Module 3: Image Blurring and the Convolution Theorem}}
\author{Adele Chinda}
\date{\today}

\begin{document}
\maketitle

%==============================================================================
\section{Problem Statement}
%==============================================================================

\textbf{Objective:} Implement image blurring using a filtering approach and demonstrate that:
\begin{enumerate}
    \item The outcome using spatial filters is the same as using the Fourier domain equivalent
    \item Convolution in space equals multiplication in the frequency (Fourier) domain
\end{enumerate}

%==============================================================================
\section{Mathematical Foundation}
%==============================================================================

\subsection{The Convolution Theorem}

The convolution theorem states that convolution in the spatial domain is equivalent to pointwise multiplication in the frequency domain:

\begin{equation}
\boxed{f \ast g = \mathcal{F}^{-1}\{\mathcal{F}\{f\} \cdot \mathcal{F}\{g\}\}}
\end{equation}

where:
\begin{itemize}
    \item $f$ is the input image
    \item $g$ is the convolution kernel (blur filter)
    \item $\mathcal{F}$ denotes the Fourier Transform
    \item $\mathcal{F}^{-1}$ denotes the Inverse Fourier Transform
    \item $\ast$ denotes convolution
    \item $\cdot$ denotes element-wise multiplication
\end{itemize}

\subsection{Spatial Domain Convolution}

For a 2D image $I(x,y)$ and kernel $K(x,y)$:
\begin{equation}
(I \ast K)(x,y) = \sum_{i=-a}^{a} \sum_{j=-b}^{b} I(x-i, y-j) \cdot K(i,j)
\end{equation}

\subsection{Frequency Domain Filtering}

The equivalent operation in the frequency domain:
\begin{equation}
I_{blurred} = \mathcal{F}^{-1}\{\mathcal{F}\{I\} \cdot \mathcal{F}\{K\}\}
\end{equation}

%==============================================================================
\section{Implementation}
%==============================================================================

\subsection{Gaussian Blur Kernel}

We use a normalized Gaussian kernel:
\begin{equation}
G(x,y) = \frac{1}{2\pi\sigma^2} e^{-\frac{x^2 + y^2}{2\sigma^2}}
\end{equation}

For a $15 \times 15$ kernel with $\sigma = 2.5$, the kernel is normalized so $\sum G(x,y) = 1$.

\subsection{Spatial Blurring Method}

\begin{lstlisting}[language=Python, basicstyle=\small\ttfamily]
from scipy.ndimage import convolve
blurred_spatial = convolve(image, kernel, mode='constant')
\end{lstlisting}

\subsection{Frequency Blurring Method}

\begin{lstlisting}[language=Python, basicstyle=\small\ttfamily]
# Zero-pad both image and kernel to same size
padded_size = (H + kh - 1, W + kw - 1)

# FFT, multiply, IFFT
F_image = np.fft.fft2(image_padded)
F_kernel = np.fft.fft2(kernel_padded)
F_result = F_image * F_kernel
result_padded = np.fft.ifft2(F_result).real

# Extract valid region
blurred_freq = result_padded[kh//2:kh//2+H, kw//2:kw//2+W]
\end{lstlisting}

%==============================================================================
\section{Results}
%==============================================================================

\subsection{Verification Metrics}

\begin{table}[H]
\centering
\begin{tabular}{@{}lc@{}}
\toprule
\textbf{Metric} & \textbf{Value} \\
\midrule
Mean Squared Error (MSE) & $1.04 \times 10^{-26}$ \\
Mean Absolute Error (MAE) & $5.34 \times 10^{-14}$ \\
Maximum Pixel Difference & $0.000000$ \\
Peak Signal-to-Noise Ratio (PSNR) & $307.96$ dB \\
\bottomrule
\end{tabular}
\caption{Comparison between spatial and frequency domain blurring results}
\label{tab:results}
\end{table}

\subsection{Interpretation}

\begin{itemize}
    \item \textbf{MSE = $1.04 \times 10^{-26}$}: This is essentially zero (machine precision), indicating the two methods produce \textbf{identical results}.
    
    \item \textbf{PSNR = 307.96 dB}: An extremely high PSNR confirms perfect equivalence. Typical ``identical'' images have PSNR $> 100$ dB.
    
    \item \textbf{Maximum Difference = 0}: No pixel differs between the two outputs.
\end{itemize}

\subsection{Visual Results}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{output/convolution_theorem_proof_k15.png}
    \caption{Comparison of original image, spatial blur, frequency blur, and difference map. The difference map is uniformly black, confirming identical results.}
    \label{fig:proof}
\end{figure}

%==============================================================================
\section{Conclusion}
%==============================================================================

\textbf{The Convolution Theorem is VERIFIED.}

Our implementation demonstrates with MSE = $1.04 \times 10^{-26}$ (machine precision) that:

\begin{equation}
\boxed{\text{Spatial Convolution} \equiv \text{Frequency Multiplication}}
\end{equation}

The results conclusively prove that blurring an image via spatial convolution produces \textbf{identical} results to multiplying in the Fourier domain and applying the inverse transform.

\vspace{1em}
\noindent\textbf{Key Implementation Details:}
\begin{itemize}
    \item Proper zero-padding ensures correct circular convolution behavior
    \item Using \texttt{scipy.ndimage.convolve} with \texttt{mode='constant'} matches FFT boundary handling
    \item Extracting the valid region from the padded FFT result ensures size consistency
\end{itemize}

%==============================================================================
\section{Files Included}
%==============================================================================

\begin{itemize}
    \item \texttt{image\_blurring\_demo.py} -- Main implementation script
    \item \texttt{output/convolution\_theorem\_proof\_k15.png} -- Visual proof
    \item \texttt{output/frequency\_analysis\_k15.png} -- FFT analysis visualization
    \item \texttt{README.md} -- Usage instructions
    \item \texttt{requirements.txt} -- Python dependencies
\end{itemize}

\end{document}
